# Reutilização de Software

## Filtragem - Strategy

O padrão de design Strategy é particularmente útil quando temos um conjunto de algoritmos que são semelhantes na sua finalidade mas variam em sua implementação. No contexto da filtragem de produtos, como indicado no UML e nos códigos fornecidos, a utilização desse padrão oferece uma série de vantagens que estão fortemente ligadas ao princípio de reutilização de software.

Primeiramente, ao definir uma interface comum Filtro, garantimos que diferentes estratégias de filtragem possam ser intercambiadas sem que a classe de contexto tenha que ser alterada. Isso não apenas promove a reutilização do código da classe de contexto, mas também permite que novas estratégias de filtro sejam adicionadas no futuro com facilidade, sem a necessidade de modificar as classes existentes.

Além disso, cada classe de estratégia é responsável apenas por uma forma de filtragem, seguindo o princípio da responsabilidade única. Isso torna cada classe mais fácil de entender, testar e manter. A reutilização é melhorada porque cada estratégia de filtragem pode ser desenvolvida e modificada de forma independente das outras, permitindo que elas sejam reutilizadas em diferentes partes do sistema onde essa forma específica de filtragem é necessária.

Outro ponto importante é a eliminação de condicionais complexas no código. Sem o uso do Strategy, a lógica de filtragem poderia resultar em um grande número de if-else ou switch statements que escolhem o algoritmo de filtragem apropriado com base em algum critério. Isso não só torna o código mais difícil de ler e manter, mas também dificulta a adição de novos critérios de filtragem. O padrão Strategy encapsula essa lógica dentro das classes de estratégia, mantendo o código da classe de contexto limpo e focado na sua função principal.

A reutilização de software é maximizada porque o padrão Strategy facilita a manutenção e a extensão das funcionalidades de filtragem. Novos filtros podem ser adicionados sem alterar o código existente, o que é uma vantagem significativa em termos de economia de tempo e recursos. Essa abordagem modular e flexível reduz o acoplamento e aumenta a coesão, o que são indicadores-chave de um bom design de software reutilizável.

<div style="text-align: center">

<figcaption style="text-align: center">
    <b>Figura 1: Diagrama filtro usando Strategy</b>
</figcaption>

![Filtro - Stategy](./assets/filter.png)

</div>
<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Lucas Frazão e Lucas Lopes)</b>
</figcaption>

<div style="text-align: center">

A imagem mostra codificação de produtos no contexto da filtragem. Essa visualização ajuda a entender como os produtos são definidos e categorizados no sistema, o que é essencial para aplicar corretamente as estratégias de filtragem.

<figcaption style="text-align: center">
    <b>Figura 2: Tipagem de produto</b>
</figcaption>

![Filtro - Tipo de Produto](./assets/filter_ProductType.jpeg)

</div>
<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Lucas Frazão e Lucas Lopes)</b>
</figcaption>

<div style="text-align: center">

Aqui, o foco é na interface Filtro, que define o contrato para as diferentes estratégias de filtragem.

<figcaption style="text-align: center">
    <b>Figura 3: Interface do Filtro</b>
</figcaption>

![Filtro - Interface](./assets/filter_interface.jpeg)

</div>
<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Lucas Frazão e Lucas Lopes)</b>
</figcaption>

<div style="text-align: center">

Esta imagem mostra um exemplo concreto de uma classe de filtro que implementa a interface Filtro.

<figcaption style="text-align: center">
    <b>Figura 4: Exemplo de um filtro que implementa a interface filtro</b>
</figcaption>

![Filtro - Stategy](./assets/filter_Price.jpeg)

</div>
<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Lucas Frazão e Lucas Lopes)</b>
</figcaption>

<div style="text-align: center">

A imagem representa a classe de contexto no padrão Strategy, que utiliza a interface Filtro. Mostra como diferentes estratégias de filtragem podem ser aplicadas em um contexto específico, demonstrando a flexibilidade e a reusabilidade do design.

<figcaption style="text-align: center">
    <b>Figura 5: Contexto para o filtro</b>
</figcaption>

![Filtro - Stategy](./assets/filter_Context.jpeg)

</div>
<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Lucas Frazão e Lucas Lopes)</b>
</figcaption>

<div style="text-align: center">

Esta figura ilustra a função principal de um programa que utiliza o padrão Strategy para filtragem. Serve para demonstrar como tudo se junta em um exemplo de aplicação real, mostrando o uso prático das classes e interfaces definidas nas imagens anteriores.

<figcaption style="text-align: center">
    <b>Figura 6: Função main</b>
</figcaption>

![Filtro - Stategy](./assets/filter_Main.jpeg)

</div>
<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Lucas Frazão e Lucas Lopes)</b>
</figcaption>

## Envio de Anexo - Decorator

O Decorator é um padrão de design estrutural que permite adicionar comportamentos adicionais ou responsabilidades a objetos de forma dinâmica. Ele permite estender as funcionalidades de um objeto sem modificar sua estrutura. Isso é alcançado por meio da criação de uma classe de decorador que envolve o objeto original, adicionando novos comportamentos ao objeto sem alterar sua implementação.

Ao usar o Decorator, é possível criar uma série de pequenos e simples objetos decoradores que podem ser combinados de várias maneiras para adicionar funcionalidades específicas a um objeto base. Isso facilita a reutilização, pois cada decorador pode ser reutilizado individualmente em diferentes contextos e combinado de maneiras diversas para criar novos comportamentos sem precisar modificar o código existente. Essa abordagem modular e flexível oferece maior adaptabilidade e extensibilidade ao software, tornando mais fácil adicionar ou remover funcionalidades, garantindo assim um alto nível de reutilização e manutenção do código.

A estrutura de um Decorator consiste em um Componente que define a interface base, um Decorator que mantém uma referência para o Componente e implementa a mesma interface, um Concrete Component que é a implementação concreta do Componente e um ou mais Concrete Decorators que estendem o Decorator base adicionando funcionalidades adicionais ao Componente. O Componente define a base, enquanto o Decorator e seus derivados oferecem a flexibilidade de adicionar dinamicamente novas responsabilidades aos objetos existentes sem alterar sua estrutura fundamental, permitindo a composição flexível de funcionalidades.

Por meio dessa estrutura, é possível agregar comportamentos adicionais a objetos existentes de maneira modular e dinâmica. O Decorator atua como uma camada flexível que pode ser combinada e empilhada para adicionar funcionalidades de forma individual e reutilizável, maximizando a flexibilidade e promovendo a reutilização de código ao permitir a criação de diferentes combinações de comportamentos.

<div style="text-align: center">

<figcaption style="text-align: center">
    <b>Figura 7: Diagrama Envio de Anexo</b>
</figcaption>

![Envio de Anexo - Decorator](./assets/Diagrama_Decorator.png)

</div>
<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Henrique Pucci e Pedro Helias)</b>
</figcaption>

<div style="text-align: center">

A interface Message define um contrato para objetos que podem enviar mensagens, exigindo que qualquer classe que a implemente contenha um método chamado sendMessage sem retorno. Essa interface serve como um contrato padrão, permitindo que diferentes tipos de mensagens, como texto simples ou mensagens com funcionalidades adicionais, sejam tratadas de maneira uniforme, garantindo a capacidade de enviar mensagens independentemente de suas implementações específicas.

<figcaption style="text-align: center">
    <b>Figura 8: Interface de Mensagem</b>
</figcaption>

![Envio de Anexo - Decorator](./assets/Decorator_Message.jpeg)

</div>
<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Henrique Pucci e Pedro Helias)</b>
</figcaption>

<div style="text-align: center">

A classe Base_Message implementa a interface Message, representando a estrutura fundamental de uma mensagem comum, contendo informações como remetente, destinatário, conteúdo e data/hora do envio. Ela fornece um método sendMessage() que exibe no console os detalhes da mensagem, incluindo a data, remetente, destinatário e conteúdo, permitindo o envio de mensagens básicas. Essa classe serve como a base para outros tipos de mensagens que podem estender ou decorar suas funcionalidades, mantendo uma estrutura consistente para o envio de mensagens.

<figcaption style="text-align: center">
    <b>Figura 9: Classe da Mensagem Base</b>
</figcaption>

![Envio de Anexo - Decorator](./assets/Decorator_Base_Message.jpeg)

</div>
<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Henrique Pucci e Pedro Helias)</b>
</figcaption>

<div style="text-align: center">

A classe Message_Decorator implementa a interface Message, atuando como um decorador que envolve objetos do tipo Message. Ela recebe uma mensagem como parâmetro em seu construtor e, ao chamar o método sendMessage(), repassa essa chamada à mensagem original. Essa classe é fundamental para o padrão Decorator, pois permite adicionar comportamentos adicionais dinamicamente a objetos existentes, sem modificar sua estrutura, facilitando a composição flexível de funcionalidades extras às mensagens.


<figcaption style="text-align: center">
    <b>Figura 10: Classe do Decorador da Mensagem</b>
</figcaption>

![Envio de Anexo - Decorator](./assets/Decorator_Message_Decorator.jpeg)

</div>
<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Henrique Pucci e Pedro Helias)</b>
</figcaption>

<div style="text-align: center">

A classe Attachment_Message estende a classe Message_Decorator e implementa a interface Message. Essa classe representa um tipo de mensagem decorada que permite adicionar anexos a uma mensagem existente. Ela recebe uma mensagem base, um nome de anexo e o conteúdo do anexo em seu construtor. Ao chamar o método sendMessage(), além de repassar a chamada à mensagem original, exibe no console os detalhes do anexo adicionado, incluindo o nome e o conteúdo. Essa classe é essencial para a adição dinâmica de funcionalidades extras às mensagens, como a inclusão de anexos, sem modificar a estrutura original da mensagem.


<figcaption style="text-align: center">
    <b>Figura 10: Classe da Implementação do Anexo em mensagem</b>
</figcaption>

![Envio de Anexo - Decorator](./assets/Decorator_Attachment_Message.jpeg)

</div>
<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Henrique Pucci e Pedro Helias)</b>
</figcaption>

<div style="text-align: center">

Na classe Main, a primeira parte faz o envio de uma mensagem simples, sem anexo, usando a classe Base_Message. A segunda parte ilustra a criação de uma mensagem com a possibilidade de anexo, inicialmente utilizando a classe Base_Message e, em seguida, acrescentando um decorador com a classe Message_Decorator e um anexo com a classe Attachment_Message. Ambos os cenários são utilizados para mostrar a funcionalidade de envio de mensagens, exibindo o funcionamento das mensagens sem e com anexo.


<figcaption style="text-align: center">
    <b>Figura 10: Classe main</b>
</figcaption>

![Envio de Anexo - Decorator](./assets/Decorator_Main.jpeg)

</div>
<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Henrique Pucci e Pedro Helias)</b>
</figcaption>