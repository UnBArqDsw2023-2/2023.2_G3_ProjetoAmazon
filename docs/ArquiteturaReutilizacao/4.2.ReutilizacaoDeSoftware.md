# Reutilização de Software

## Filtragem - Strategy

O padrão de design Strategy é particularmente útil quando temos um conjunto de algoritmos que são semelhantes na sua finalidade mas variam em sua implementação. No contexto da filtragem de produtos, como indicado no UML e nos códigos fornecidos, a utilização desse padrão oferece uma série de vantagens que estão fortemente ligadas ao princípio de reutilização de software.

Primeiramente, ao definir uma interface comum Filtro, garantimos que diferentes estratégias de filtragem possam ser intercambiadas sem que a classe de contexto tenha que ser alterada. Isso não apenas promove a reutilização do código da classe de contexto, mas também permite que novas estratégias de filtro sejam adicionadas no futuro com facilidade, sem a necessidade de modificar as classes existentes.

Além disso, cada classe de estratégia é responsável apenas por uma forma de filtragem, seguindo o princípio da responsabilidade única. Isso torna cada classe mais fácil de entender, testar e manter. A reutilização é melhorada porque cada estratégia de filtragem pode ser desenvolvida e modificada de forma independente das outras, permitindo que elas sejam reutilizadas em diferentes partes do sistema onde essa forma específica de filtragem é necessária.

Outro ponto importante é a eliminação de condicionais complexas no código. Sem o uso do Strategy, a lógica de filtragem poderia resultar em um grande número de if-else ou switch statements que escolhem o algoritmo de filtragem apropriado com base em algum critério. Isso não só torna o código mais difícil de ler e manter, mas também dificulta a adição de novos critérios de filtragem. O padrão Strategy encapsula essa lógica dentro das classes de estratégia, mantendo o código da classe de contexto limpo e focado na sua função principal.

A reutilização de software é maximizada porque o padrão Strategy facilita a manutenção e a extensão das funcionalidades de filtragem. Novos filtros podem ser adicionados sem alterar o código existente, o que é uma vantagem significativa em termos de economia de tempo e recursos. Essa abordagem modular e flexível reduz o acoplamento e aumenta a coesão, o que são indicadores-chave de um bom design de software reutilizável.

<div style="text-align: center">

<figcaption style="text-align: center">
    <b>Figura 1: Diagrama filtro usando Strategy</b>
</figcaption>

![Filtro - Stategy](./assets/filter.png)

</div>
<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Lucas Frazão e Lucas Lopes)</b>
</figcaption>

<div style="text-align: center">

A imagem mostra codificação de produtos no contexto da filtragem. Essa visualização ajuda a entender como os produtos são definidos e categorizados no sistema, o que é essencial para aplicar corretamente as estratégias de filtragem.

<figcaption style="text-align: center">
    <b>Figura 2: Tipagem de produto</b>
</figcaption>

![Filtro - Tipo de Produto](./assets/filter_ProductType.jpeg)

</div>
<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Lucas Frazão e Lucas Lopes)</b>
</figcaption>

<div style="text-align: center">

Aqui, o foco é na interface Filtro, que define o contrato para as diferentes estratégias de filtragem.

<figcaption style="text-align: center">
    <b>Figura 3: Interface do Filtro</b>
</figcaption>

![Filtro - Interface](./assets/filter_interface.jpeg)

</div>
<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Lucas Frazão e Lucas Lopes)</b>
</figcaption>

<div style="text-align: center">

Esta imagem mostra um exemplo concreto de uma classe de filtro que implementa a interface Filtro.

<figcaption style="text-align: center">
    <b>Figura 4: Exemplo de um filtro que implementa a interface filtro</b>
</figcaption>

![Filtro - Stategy](./assets/filter_Price.jpeg)

</div>
<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Lucas Frazão e Lucas Lopes)</b>
</figcaption>

<div style="text-align: center">

A imagem representa a classe de contexto no padrão Strategy, que utiliza a interface Filtro. Mostra como diferentes estratégias de filtragem podem ser aplicadas em um contexto específico, demonstrando a flexibilidade e a reusabilidade do design.

<figcaption style="text-align: center">
    <b>Figura 5: Contexto para o filtro</b>
</figcaption>

![Filtro - Stategy](./assets/filter_Context.jpeg)

</div>
<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Lucas Frazão e Lucas Lopes)</b>
</figcaption>

<div style="text-align: center">

Esta figura ilustra a função principal de um programa que utiliza o padrão Strategy para filtragem. Serve para demonstrar como tudo se junta em um exemplo de aplicação real, mostrando o uso prático das classes e interfaces definidas nas imagens anteriores.

<figcaption style="text-align: center">
    <b>Figura 6: Função main</b>
</figcaption>

![Filtro - Stategy](./assets/filter_Main.jpeg)

</div>
<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Lucas Frazão e Lucas Lopes)</b>
</figcaption>


## Estados de devolução - State

O padrão de projeto State é extremamente útil para o gerenciamento de estado em situações onde um objeto pode alterar seu comportamento quando o seu estado interno muda. Quando lidamos com devoluções, temos diferentes estados pelos quais um item pode passar: pendente, em análise, aceito, rejeitado, entre outros. Cada estado desses pode ter comportamentos específicos associados, como verificar se o item está danificado, notificar o cliente sobre a aceitação ou rejeição da devolução, entre outros.

O padrão State permite modelar cada estado da devolução como uma classe separada, encapsulando o comportamento específico associado a cada estado. Isso ajuda a manter o código organizado, facilitando a adição de novos estados e evitando que a lógica relacionada a diferentes estados se misture. Além disso, o padrão State promove a coesão e a manutenção do código, já que cada estado está isolado em sua própria classe, tornando mais fácil entender, testar e modificar o comportamento de cada estado sem afetar os outros.

A **Figura 7** apresenta a modelagem do padrão state no contexto de gerenciamento de estados da devolução.

<figcaption style="text-align: center">
    <b>Figura 7: Modelagem do gerenciamento de estados da devolução utilizando o padrão state.</b>
</figcaption>

![Modelagem - state](./assets/state.png)

<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Samuel Gomes e Gabriel Ferreira)</b>
</figcaption>


Agora, será mostrada a implementação desse padrão. Começando com a implementação da interface como mostra a **Figura 8**. A interface no padrão State é essencial como uma estrutura comum para os diferentes estados. Ela define os métodos que representam as operações possíveis nos estados. Essa abstração permite que os estados concretos implementem esses métodos de forma específica, garantindo que o contexto possa interagir uniformemente com os estados, independente de suas particularidades. Isso mantém a flexibilidade do código ao adicionar novos estados sem mudar a interface do contexto.

<figcaption style="text-align: center">
    <b>Figura 8: Implementação da Interface</b>
</figcaption>

![Código da interface](./assets/state-interface.png)

<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Samuel Gomes e Gabriel Ferreira)</b>
</figcaption>

A **Figura 9** apresenta a implementação do contexto. O contexto no padrão State é responsável por conter uma instância do estado atual e por delegar as chamadas dos métodos para o estado correspondente. Ele interage diretamente com a interface do estado, possibilitando a mudança dinâmica do estado em tempo de execução. Além disso, o contexto fornece métodos que permitem a transição entre os diferentes estados, controlando o fluxo da aplicação e coordenando as operações conforme o estado atual. Essa separação entre o contexto e os estados permite que o contexto mantenha seu funcionamento independentemente das mudanças nos comportamentos dos estados.

<figcaption style="text-align: center">
    <b>Figura 9: Implementação do contexto</b>
</figcaption>

![Código da interface](./assets/state-context.png)

<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Samuel Gomes e Gabriel Ferreira)</b>
</figcaption>


As **Figuras 10 a 15** mostram a implementação dos estados. Os estados no padrão State representam as diferentes condições que um objeto pode assumir, influenciando o seu comportamento. Cada estado é encapsulado em uma classe separada, implementando a interface comum. Isso permite que o objeto mude seu comportamento dinamicamente, adaptando-se a diferentes situações sem a necessidade de condicionais complexos. Cada classe de estado contém a lógica específica relacionada ao seu estado, proporcionando uma organização modular e facilitando a extensão do código ao adicionar novos estados.


A **Figura 10** apresenta a implementação do estado de devolução pendente.

<figcaption style="text-align: center">
    <b>Figura 10: Implementação do estado de devolução pendente</b>
</figcaption>

![Implementação estado pendente](./assets/state-pendente.png)

<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Samuel Gomes e Gabriel Ferreira)</b>
</figcaption>

<br />

A **Figura 11** apresenta a implementação do estado de devolução aprovada.

<figcaption style="text-align: center">
    <b>Figura 11: Implementação do estado de devolução aprovada</b>
</figcaption>

![Implementação estado aprovado](./assets/state-aprovado.png)

<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Samuel Gomes e Gabriel Ferreira)</b>
</figcaption>

<br />

A **Figura 12** apresenta a implementação do estado de devolução rejeitada.

<figcaption style="text-align: center">
    <b>Figura 12: Implementação do estado de devolução rejeitada</b>
</figcaption>

![Implementação estado rejeitado](./assets/state-rejeitado.png)

<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Samuel Gomes e Gabriel Ferreira)</b>
</figcaption>

<br />

A **Figura 13** apresenta a implementação do estado de devolução em análise.

<figcaption style="text-align: center">
    <b>Figura 13: Implementação do estado de devolução em análise</b>
</figcaption>

![Implementação estado em análise](./assets/state-em-analise.png)

<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Samuel Gomes e Gabriel Ferreira)</b>
</figcaption>

<br />

A **Figura 14** apresenta a implementação do estado de devolução em trânsito.

<figcaption style="text-align: center">
    <b>Figura 14: Implementação do estado de pedido em trânsito</b>
</figcaption>

![Implementação estado em trânsito](./assets/state-em-transito.png)

<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Samuel Gomes e Gabriel Ferreira)</b>
</figcaption>

<br />

A **Figura 15** apresenta a implementação do estado de devolução concluída.

<figcaption style="text-align: center">
    <b>Figura 15: Implementação do estado de devolução concluída</b>
</figcaption>

![Implementação devolução concluída](./assets/state-concluido.png)

<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Samuel Gomes e Gabriel Ferreira)</b>
</figcaption>

<br />

Na **Figura 16**, o código ilustra as alterações de estado do objeto "pedido_devolucao".

<figcaption style="text-align: center">
    <b>Figura 16: Implementação do estado de devolução concluída</b>
</figcaption>

![Transição de estados](./assets/state-transicao.png)

<figcaption style="text-align: center">
   <b>Autor: Elaboração Própria (Samuel Gomes e Gabriel Ferreira)</b>
</figcaption>





